@inproceedings{flanagan,
	author = {Flanagan, Cormac and Freund, Stephen},
	year = {2009},
	month = {06},
	pages = {121-133},
	title = {{FastTrack: Efficient and Precise Dynamic Race Detection}},
	volume = {53},
	journal = {Communications of The ACM - CACM},
	doi = {10.1145/1542476.1542490}
}

@article{sulzmann,
	author       = {Martin Sulzmann and
	Kai Stadtm{\"{u}}ller},
	title        = {{Efficient, Near Complete and Often Sound Hybrid Dynamic Data Race
	Prediction (extended version)}},
	journal      = {CoRR},
	volume       = {abs/2004.06969},
	year         = {2020},
	url          = {https://arxiv.org/abs/2004.06969},
	eprinttype    = {arXiv},
	eprint       = {2004.06969},
	timestamp    = {Tue, 21 Apr 2020 16:51:52 +0200},
	biburl       = {https://dblp.org/rec/journals/corr/abs-2004-06969.bib},
	bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@misc{SWB-1830643851,
	title = {{Distributed Computing and Intelligent Technology : 19th International Conference, ICDCIT 2023, Bhubaneswar, India, January 18–22, 2023, Proceedings}},
	series = {Lecture Notes in Computer Science ; 13776},
	editor = {Anisur Rahaman Molla and Gokarna Sharma and Pradeep Kumar and Sanjay Rawat},
	address = {Cham},
	publisher = {Springer Nature Switzerland},
	year = {2023},
	edition = {1st ed. 2023.},
	isbn = {9783031248481},
	size = {1 Online-Ressource(XXIII, 376 p. 174 illus., 130 illus. in color.)},
	URL = {https://link.springer.com/book/10.1007/978-3-031-24848-1},
}


@article{FAVA2020102473,
	title = {{Ready, set, Go!: Data-race detection and the Go language}},
	journal = {Science of Computer Programming},
	volume = {195},
	pages = {102473},
	year = {2020},
	issn = {0167-6423},
	doi = {https://doi.org/10.1016/j.scico.2020.102473},
	url = {https://www.sciencedirect.com/science/article/pii/S0167642320300836},
	author = {Daniel Schnetzer Fava and Martin Steffen},
	keywords = {Concurrency, Synchronization, Message passing, Data-race detection, Golang},
	abstract = {Data races are often discussed in the context of lock acquisition and release, with race-detection algorithms routinely relying on vector clocks as a means of capturing the relative ordering of events from different threads. In this paper, we present a data-race detector for a language with channel communication as its sole synchronization primitive, and provide a semantics directly tied to the happens-before relation, thus forging the notion of vector clocks.}
}

@article{lamport,
	author = {Lamport, Leslie},
	title = {{Time, Clocks, and the Ordering of Events in a Distributed System}},
	year = {1978},
	issue_date = {July 1978},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	volume = {21},
	number = {7},
	issn = {0001-0782},
	url = {https://doi.org/10.1145/359545.359563},
	doi = {10.1145/359545.359563},
	abstract = {The concept of one event happening before another in a distributed system is examined, and is shown to define a partial ordering of the events. A distributed algorithm is given for synchronizing a system of logical clocks which can be used to totally order the events. The use of the total ordering is illustrated with a method for solving synchronization problems. The algorithm is then specialized for synchronizing physical clocks, and a bound is derived on how far out of synchrony the clocks can become.},
	journal = {Commun. ACM},
	month = {jul},
	pages = {558–565},
	numpages = {8},
	keywords = {computer networks, distributed systems, clock synchronization, multiprocess systems}
}


@misc{sulzmann2,
	author = {Martin Sulzmann},
	title = {Dynamic data race prediction},
	url = {https://sulzmann.github.io/AutonomeSysteme/lec-data-race.html},
	addendum= {accessed Jun. 5, 2023}
}


@article{marthur,
	author = {Mathur, Umang and Kini, Dileep and Viswanathan, Mahesh},
	title = {{What Happens-after the First Race? Enhancing the Predictive Power of Happens-before Based Dynamic Race Detection}},
	year = {2018},
	issue_date = {November 2018},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	volume = {2},
	number = {OOPSLA},
	url = {https://doi.org/10.1145/3276515},
	doi = {10.1145/3276515},
	abstract = {Dynamic race detection is the problem of determining if an observed program execution reveals the presence of a data race in a program. The classical approach to solving this problem is to detect if there is a pair of conflicting memory accesses that are unordered by Lamport’s happens-before (HB) relation. HB based race detection is known to not report false positives, i.e., it is sound. However, the soundness guarantee of HB only promises that the first pair of unordered, conflicting events is a schedulable data race. That is, there can be pairs of HB-unordered conflicting data accesses that are not schedulable races because there is no reordering of the events of the execution, where the events in race can be executed immediately after each other. We introduce a new partial order, called schedulable happens-before (SHB) that exactly characterizes the pairs of schedulable data races — every pair of conflicting data accesses that are identified by SHB can be scheduled, and every HB-race that can be scheduled is identified by SHB. Thus, the SHB partial order is truly sound. We present a linear time, vector clock algorithm to detect schedulable races using SHB. Our experiments demonstrate the value of our algorithm for dynamic race detection — SHB incurs only little performance overhead and can scale to executions from real-world software applications without compromising soundness.},
	journal = {Proc. ACM Program. Lang.},
	month = {oct},
	articleno = {145},
	numpages = {29},
	keywords = {Dynamic Program Analysis, Happens-Before, Race Detection, Concurrency, Soundness}
}

@INPROCEEDINGS{yu,
	
	author={Yu, Lechen and Jin, Feiyang and Protze, Joachim and Sarkar, Vivek},
	
	booktitle={{2022 IEEE/ACM Sixth International Workshop on Software Correctness for HPC Applications (Correctness)}}, 
	
	title={{Leveraging the Dynamic Program Structure Tree to Detect Data Races in OpenMP Programs}}, 
	
	year={2022},
	
	volume={},
	
	number={},
	
	pages={54-62},
	
	doi={10.1109/Correctness56720.2022.00012}}


@article{naik,
	author = {Naik, Mayur and Aiken, Alex and Whaley, John},
	title = {{Effective Static Race Detection for Java}},
	year = {2006},
	issue_date = {June 2006},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	volume = {41},
	number = {6},
	issn = {0362-1340},
	url = {https://doi.org/10.1145/1133255.1134018},
	doi = {10.1145/1133255.1134018},
	abstract = {We present a novel technique for static race detection in Java programs, comprised of a series of stages that employ a combination of static analyses to successively reduce the pairs of memory accesses potentially involved in a race. We have implemented our technique and applied it to a suite of multi-threaded Java programs. Our experiments show that it is precise, scalable, and useful, reporting tens to hundreds of serious and previously unknown concurrency bugs in large, widely-used programs with few false alarms.},
	journal = {SIGPLAN Not.},
	month = {jun},
	pages = {308–319},
	numpages = {12},
	keywords = {synchronization, static race detection, concurrency, Java, multi-threading}
}


@INPROCEEDINGS{atzeni,
	
	author={Atzeni, Simone and Gopalakrishnan, Ganesh and Rakamaric, Zvonimir and Laguna, Ignacio and Lee, Gregory L. and Ahn, Dong H.},
	
	booktitle={{2018 IEEE International Parallel and Distributed Processing Symposium (IPDPS)}}, 
	
	title={SWORD: A Bounded Memory-Overhead Detector of OpenMP Data Races in Production Runs}, 
	
	year={2018},
	
	volume={},
	
	number={},
	
	pages={845-854},
	
	doi={10.1109/IPDPS.2018.00094}}


@INPROCEEDINGS{wilcox,
	
	author={Wilcox, James R. and Finch, Parker and Flanagan, Cormac and Freund, Stephen N.},
	
	booktitle={{2015 30th IEEE/ACM International Conference on Automated Software Engineering (ASE)}}, 
	
	title={{Array Shadow State Compression for Precise Dynamic Race Detection (T)}}, 
	
	year={2015},
	
	volume={},
	
	number={},
	
	pages={155-165},
	
	doi={10.1109/ASE.2015.19}
}


@InProceedings{lin,
	author="{Lin, Pei-Hung and Liao, Chunhua and Schordan, Markus and Karlin, Ian}",
	editor={Margaria, Tiziana
	and Steffen, Bernhard},
	title={{Runtime and Memory Evaluation of Data Race Detection Tools}},
	booktitle={{Leveraging Applications of Formal Methods, Verification and Validation. Verification}},
	year="2018",
	publisher="Springer International Publishing",
	address="Cham",
	pages="179--196",
	abstract="An analysis tool's usefulness depends on whether its runtime and memory consumption remain within reasonable bounds for a given program. In this paper we present an evaluation of the memory consumption and runtime of four data race detection tools: Archer, ThreadSanitizer, Helgrind, and Intel Inspector, using DataRaceBench version 1.1.1 using 79 microbenchmarks. Our evaluation consists of four different analyses: (1) runtime and memory consumption of the four data race detection tools using all DataRaceBench microbenchmarks, (2) comparison of the analysis techniques implemented in the evaluated tools, (3) for selected benchmarks an in-depth analysis of runtime behavior with CPU profiler and the identified differences, (4) data analysis to investigate correlations within collected data. We also show the effectiveness of the tools using three quantitative metrics: precision, recall, and accuracy.",
	isbn="978-3-030-03421-4"
}

@article{10.1145/3093333.3009857,
	author = {Lidbury, Christopher and Donaldson, Alastair F.},
	title = {Dynamic Race Detection for C++11},
	year = {2017},
	issue_date = {January 2017},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	volume = {52},
	number = {1},
	issn = {0362-1340},
	url = {https://doi.org/10.1145/3093333.3009857},
	doi = {10.1145/3093333.3009857},
	abstract = {The intricate rules for memory ordering and synchronisation associated with the C/C++11 memory model mean that data races can be difficult to eliminate from concurrent programs. Dynamic data race analysis can pinpoint races in large and complex applications, but the state-of-the-art ThreadSanitizer (tsan) tool for C/C++ considers only sequentially consistent program executions, and does not correctly model synchronisation between C/C++11 atomic operations. We present a scalable dynamic data race analysis for C/C++11 that correctly captures C/C++11 synchronisation, and uses instrumentation to support exploration of a class of non sequentially consistent executions. We concisely define the memory model fragment captured by our instrumentation via a restricted axiomatic semantics, and show that the axiomatic semantics permits exactly those executions explored by our instrumentation. We have implemented our analysis in tsan, and evaluate its effectiveness on benchmark programs, enabling a comparison with the CDSChecker tool, and on two large and highly concurrent applications: the Firefox and Chromium web browsers. Our results show that our method can detect races that are beyond the scope of the original tsan tool, and that the overhead associated with applying our enhanced instrumentation to large applications is tolerable.},
	journal = {SIGPLAN Not.},
	month = {jan},
	pages = {443–457},
	numpages = {15},
	keywords = {C++11, data races, memory models, concurrency}
}



@inproceedings{lidbury,
	author = {Lidbury, Christopher and Donaldson, Alastair F.},
	title = {{Dynamic Race Detection for C++11}},
	year = {2017},
	isbn = {9781450346603},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/3009837.3009857},
	doi = {10.1145/3009837.3009857},
	abstract = {The intricate rules for memory ordering and synchronisation associated with the C/C++11 memory model mean that data races can be difficult to eliminate from concurrent programs. Dynamic data race analysis can pinpoint races in large and complex applications, but the state-of-the-art ThreadSanitizer (tsan) tool for C/C++ considers only sequentially consistent program executions, and does not correctly model synchronisation between C/C++11 atomic operations. We present a scalable dynamic data race analysis for C/C++11 that correctly captures C/C++11 synchronisation, and uses instrumentation to support exploration of a class of non sequentially consistent executions. We concisely define the memory model fragment captured by our instrumentation via a restricted axiomatic semantics, and show that the axiomatic semantics permits exactly those executions explored by our instrumentation. We have implemented our analysis in tsan, and evaluate its effectiveness on benchmark programs, enabling a comparison with the CDSChecker tool, and on two large and highly concurrent applications: the Firefox and Chromium web browsers. Our results show that our method can detect races that are beyond the scope of the original tsan tool, and that the overhead associated with applying our enhanced instrumentation to large applications is tolerable.},
	booktitle = {Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages},
	pages = {443–457},
	numpages = {15},
	keywords = {data races, C++11, memory models, concurrency},
	location = {Paris, France},
	series = {POPL '17}
}

