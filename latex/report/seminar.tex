%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%| !!! TEMPLATE INSPIRED BY https://github.com/ocjojo/hska-latex-template                  !!! |%%
%%| !!! HsKa_old.jpg CAN BE FOUND HERE: https://de.wikipedia.org/wiki/Datei:Hska_logo.svg   !!! |%%
%%| !!! HsKa_new.png WAS CREATED BY USAGE OF IMAGERY FROM: https://www.h-ka.de/intern       !!! |%% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%| SET DOCUMENT PARAMTER HERE |%%
\documentclass[12pt]{article}

%%| INCLUDE PACKAGES HERE |%%
\usepackage[utf8]{inputenc}
\usepackage[paper=a4paper,left=25mm,right=25mm,top=25mm,bottom=25mm]{geometry}
%% enable for german
%% \usepackage[english, ngerman]{babel}
\usepackage[english]{babel}
\usepackage{graphicx}
\graphicspath{ {./images/} }
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[autostyle=true]{csquotes}
\usepackage[backend=bibtex, style=ieee]{biblatex}
\AtBeginEnvironment{quote}{\small}
\usepackage{hyperref}
\usepackage{setspace}
\usepackage{microtype}
\usepackage{listings}
\usepackage{float}
\lstset{inputpath=./listings/}
\renewcommand\lstlistlistingname{List of Listings}

\usepackage{tikz}
\usetikzlibrary{tikzmark}

%%| SET PACKAGE PARAMETERS HERE |%%
\hypersetup{                                                           
	colorlinks,
	citecolor   = red,
	filecolor   = red,
	linkcolor   = red,
	urlcolor    = black,
	pdftitle    = {Seminararbeit},                                               % SET FILE PARAMETERS HERE (SHOWN IN PDF PROPERTIES)
	pdfsubject  = {Dynamische Programmanalysen für nebenläufige Programme - Data Race Prediction mit TSan V2},                                       % ...
	pdfauthor   = {Frank Ling},                                                 % ...
	pdfkeywords = {Seminararbeit, Seminar} ,                                    % ...
	pdfcreator  = {pdflatex},           
	pdfproducer = {LaTeX with hyperref}
}
\setstretch{1.25}                                                                   % SET GENERAL LINE SPACING HERE

%\lstdefinestyle{customc}{
%	belowcaptionskip=1\baselineskip,
%	breaklines=true,
%	frame=L,
%	xleftmargin=\parindent,
%	language=C,
%	showstringspaces=false,
%	basicstyle=\footnotesize\ttfamily,
%	keywordstyle=\bfseries\color{green!40!black},
%	commentstyle=\itshape\color{purple!40!black},
%	identifierstyle=\color{blue},
%	stringstyle=\color{orange},
%}
\lstdefinestyle{customc}{
	belowcaptionskip=1\baselineskip,
	breaklines=true,
	numbers=left,
	columns=flexible,
	xleftmargin=2em,
	xrightmargin=1em,
	firstnumber=1,
	numberfirstline,
	numberstyle=\tiny\sffamily,
	numbersep=6pt,
	basicstyle=\footnotesize\ttfamily,
	keywordstyle=\bfseries\color{green!40!black},
	commentstyle=\itshape\color{purple!40!black},
	identifierstyle=\color{blue},
	backgroundcolor=\color{gray!10!white},
}
\lstset{style=customc}
\lstset{captionpos=b}

%%| SET OTHER PARAMETERS HERE |%%
\addbibresource{document/bibliography/ref.bib}
%% clearpage before every section
\AddToHook{cmd/section/before}{\clearpage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%| TITLE PAGE |%%
\begin{document}
	\begin{titlepage}
		\begin{center}
			\includegraphics[width=0.55\textwidth]{images/hka-logo.png}\\[16ex]
			\LARGE{\textbf{Dynamische Programmanalysen für nebenläufige Programme - Data Race Prediction mit TSan V2}}\\[8ex]
			\Large{{Seminararbeit}}\\[14ex]
			\normalsize{}
			\begin{tabular}{lll}
				Student:            & \quad Frank Ling                                  & \\[2ex]
				Matrikelnummer:     & \quad 79496 & \\[2ex]     % NUMBER IS MAT.NR
				Universität:        & \quad Hochschule Karlsruhe – Technik und Wirtschaft   &       \\[2ex]
				Studiengang:        & \quad Informatik, Master                &       \\[2ex]
				Semester:           & \quad Sommersemester 2023                             &       \\[2ex]
				Betreuer:             & \quad Prof. Martin Sulzmann                       &       \\[2ex]
				Bearbeitet am:      & \quad \today                                  &       \\[2ex]
			\end{tabular}
		\end{center}
	\end{titlepage}
	\newpage
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%%| TABLE OF CONTENTS |%%
	\pagenumbering{gobble}
	{\hypersetup{linkcolor=black} 
	\tableofcontents}
	\newpage
	\pagenumbering{arabic}
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%%| WRITE TEXT HERE |%%
	\section{Introduction}
	Nowadays concurrent programs are very common in order to make use of 'hyper-threading and multi-core architectures'\cite[p. 14]{SWB-1830643851}. 'Due to the highly non-deterministic behavior of concurrent programs' \cite[p. 1]{sulzmann} data races may arise but can also be hard to find, as they also 'may only arise under a specific schedule' \cite[p. 1]{sulzmann}. This will be elaborated in the following section. We specifically look at the dynamic data race prediction algorithms of FastTrack and ThreadSanitizer (TSan) V2. TSan V2 uses a slightly modified version of the FastTrack algorithm and differentiates itself from the first version by utilizing happens-before methods instead of the lockset method.\\
	Firstly the motivation and background for dynamic data race prediction tools will be shown. Then the FastTrack and TSan algorithms will be demonstrated along with examples showing the limitations of FastTrack and TSan. In the following the same notation as in \cite{sulzmann} will be used for traces and events.
%	\begin{description}
%		\item[data race] concurrent programs prone to data races, due to highly nondeterministic nature. 2 conflicting events next to each other in trace
%		\item[conflicting event] 2 read/write events, at least one event is write event
%		\item[dynamic data race prediction] predict trace orderings that exhibit data races
%		\item[exhaustive predictive methods] identify as many orderings as possible
%		\item[efficient predictive methods] \(O(n)\) runtime, compromise completeness and soundness
%		\item[HB relation] events can be ordered by happens-before relation and if they can't that means they can be ordered in a way that they are next to each other in the trace $\rightarrow$ data race
%		\item[vector clocks] used to represent happens-before relation, if incomparable then data race
%		\item[epochs] vector clocks need \(O(n)\) time and space, instead epochs can be used which consist of time stamp j and thread id k $\rightarrow$ j\#k
%	\end{description}

	\section{Motivation and Examples}
	As stated in the introduction concurrent programs are commonly used and are inherently prone to data races. The problem with data races is that they can cause undefined behavior and crashes while also being hard to reproduce. This makes data races hard to find and they might not always be apparent. This chapter will show a few examples from \cite{sulzmann2} but rewritten in the programming language C++. The following example shows a program, which exhibits a data race (see chapter \ref{background-sec}):
	\lstinputlisting[caption={Program containing conflicting events}, label={lst:conflicting}, language=C++]{conflicting_event.cpp}
	Generally the corresponding event in the resulting trace is seen above each operation as a comment in the code. For example acquiring and releasing a lock is accomplished by the \texttt{pthread\_mutex\_lock()}- and the \texttt{pthread\_mutex\_unlock()}-method, which is used in line 10, where a lock on the variable \texttt{var2} is acquired. The corresponding event in the trace would be $1\#acq(y)_2$ which is indicated by the method name and the comment above in line 9. The method name shows which thread the event is from and the comment specifies the event. As a write event a variable can simply be incremented or assigned a value. A simple read event could be printing a variable in the console as it accesses the value of the variable. The following trace can be generated for the program \ref{lst:conflicting}:
	\begin{table}[H]
		\begin{center}
			\begin{tabular}{ c c c}
				& 1\# & 2\# \\
				\hline
				1. & w(x) & \\
				2. & acq(y) & \\
				3. & rel(y) & \\
				4. & & acq(y) \\
				5. & & w(x) \\
				6. & & rel(y) \\
			\end{tabular}
			\caption{Possible trace of listing \ref{lst:conflicting}}
			\label{trace1}
		\end{center}
	\end{table}
	In the trace \ref{trace1} the events $1\#w(x)_1$ and $2\#w(x)_5$ do not appear right next to each other which might indicate that these two events are not part of a data race. By rerunning the program \ref{lst:conflicting} eventually the following trace can be obtained:
	\begin{table}[H]
		\begin{center}
			\begin{tabular}{ c c c}
				& 1\# & 2\# \\
				\hline
				4. & & acq(y) \\
				5. & & w(x) \\
				1. & w(x) & \\
				6. &  & rel(y) \\
				2. & acq(y) & \\
				3. & rel(y) & \\
			\end{tabular}
			\caption{Trace \ref{trace1} reordered}
			\label{trace2}
		\end{center}
	\end{table}
	The trace \ref{trace2} shows the two events $1\#w(x)_1$ and $2\#w(x)_5$ are now next to each other in the trace, thus they are part of a data race. This also shows that there are data races that can only be detected under a specific schedule. Data race prediction tools use various methods to try to predict such cases.
	\section{Background}\label{background-sec}
		\subsection{Dynamic Data Race Prediction}
		Race prediction can be done statically or dynamically. Static race prediction uses static analysis, meaning it tries to find data races before running the code. For more details on static race prediction see \cite{naik}.\\
		Dynamic data race prediction tools run a program and then, based on the obtained trace, try to predict if there may be a reordered trace that exhibits data races, see \cite[p. 2]{sulzmann2}.\\
		The approach of finding all possible reorderings is used in exhaustive predictive methods. Since modern programs may utilize multiple threads each executing large, computationally intensive blocks of code, finding all possible reorderings might not always be feasible. Therefore effective predictive methods are employed which compromise \textit{completeness} and \textit{soundness} for better coverage. FastTrack and TSan are examples for dynamic data race prediction using effective predictive methods.\\
		Sulzmann and Stadtm\"uller \cite[p. 2]{sulzmann} define completeness and soundness as follows:
		\begin{quote}
			Sound means that races reported by the algorithm can be observed via some appropriate reordering of the trace. If unsound, we refer to wrongly a classiﬁed race as a \textit{false positive}. Complete means that all valid reorderings that exhibit some race can be predicted by the algorithm. If incomplete, we refer to any not reported race as a \textit{false negative}.
		\end{quote}
		\subsection{Happens-Before Relation and Data Race}
		As stated in \cite[p. 4]{sulzmann2}, the happens-before relation is used to partially order the events in a system. The happens-before relation is defined as a strict partial order so the ordering is transitive but irreflexive.\\
		Events can either be ordered and therefore a happens-before relation can be established between them, or they can not be ordered in which case both events 'are said to be \textit{concurrent}' \cite[p. 2]{lamport}. Further two events '[...]\textit{conflict} if they both access (read or write) the same variable, and at least one of the operations is a write. Using this terminology, a trace has a race condition if it has two concurrent conflicting accesses.' \cite[p. 2]{flanagan}. An example of a data race can be seen in the trace \ref{trace2}.\\
		In FastTrack and TSan Lamport's happens-before relation \cite{lamport}, referred to as HB relation, is used. The HB relation additionally to the above imposes the program order condition and critical section order condition. The program order condition defines that two events $e$ and $f$ belonging to the same thread, with $e$ appearing before $f$ in the trace, then $e <^{HB} f$ applies. $<^{HB}$ denotes the HB ordering relation. The critical section order condition imposes that for two acquire and release events $acq(y)$ and $rel(y)$ on the same lock $y$ where both events result from different threads with $rel(y)$ appearing before $acq(y)$ in the trace, then $rel(y) <^{HB} acq(y)$ applies \cite[p. 4]{sulzmann2}.
		\subsection{Vector-Clock}
		As stated by Flanagan and Freund \cite[p. 1]{flanagan}:
		\begin{quote}
			Typically, the happens-before relation is represented using vector clocks (VCs) [...]. Vector clocks are expensive, however, because they record information about each thread in a system. Thus, if the target program has n threads, then each VC requires O(n) storage space and each VC operation requires O(n) time.
			Motivated in part by the performance limitations of vector
			clocks, a variety of alternative imprecise race detectors have been developed, which may provide better coverage but can report false alarms on race-free programs.
		\end{quote}
		Sulzmann and Stadtm\"uller define vector clocks as follows \cite[p. 7]{sulzmann}:
		\begin{quote}
			A vector clock $V$ is a list of time
			stamps of the following form.
			\begin{equation}
				v ::= [i_1,...,i_n]
			\end{equation}
			We assume vector clocks are of a ﬁxed size $n$. Time stamps are natural numbers and each time stamp position $j$ corresponds to the thread with identiﬁer $j$. We deﬁne
			\begin{equation}
				[i_1,...,i_n]\sqcup[j_i,...,j_n] = [\text{max}(i_1,j_1),...,\text{max}(i_n,j_n)]
			\end{equation}
			to synchronize two vector clocks by building the point-wise maximum.
			We write $V[j]$ to access the time stamp at position $j$. We write inc$(V,j)$ as a short-hand for incrementing the vector clock $V$ at position $j$ by one.
			We deﬁne vector clock $V_1$ to be smaller than vector clock $V_2$, written $V_1 < V_2$, if (1) for each thread $i$, $i$'s time stamp in $V_1$ is smaller or equal compared to $i$'s time stamp in $V_2$, and (2) there exists a thread $i$ where $i$'s time stamp in $V_1$ is strictly smaller compared to $i$'s time stamp in $V_2$. [...] For each thread $i$ we maintain a vector clock $Th(i)$. [...]Initially, for each vector clock $Th(i)$ all time stamps are set to 0 but position $i$ where the time stamp is set to 1.
		\end{quote}
		Sulzmann and Stadtm\"uller further state that for two events $e$ and $f$ with vector clocks $V_1$ assigned to $e$ and $V_2$ assigned to $f$, if $V_1 < V_2$ then it can be said that $e <^{HB} f$. Further for synchronization the following applies. $V_1 = V_2 \sqcup V_3$ then $V_1 \leq V_2$ and $V_1 \leq V_3$.\\
		For the cases where neither $V_1 < V_2$ nor $V_2 < V_1$ is true it can be said that $V_1$ and $V_2$ are incomparable \cite[p. 8]{sulzmann2}. The events assigned with $V_1$ and $V_2$ are therefore concurrent. If at least one of the events is a write event, then a data race has been found.\\ 
		With Lamport's HB relation for events in the same thread $j$ with the respective vector clock $V_n$, the operation $\text{inc}(V_n,j)$ is applied after processing the event. This is to enforce the program order condition. That results in events having a pre vector clock $\text{pre\_}V$ and a post vector clock $\text{post\_}V$. As an example in trace \ref{trace1}, 1\#w(x) will have the pre vector clock $[1,0]$, as we are in the first thread we must initialize set the time stamp at position one to zero. Then $\text{inc}(\text{pre\_}V_1,1)$ is applied so the post vector clock would be $\text{post\_}V_1=[2,0]$. For following events in the same thread the pre vector clock is the same as the post vector clock of the previous event. So for 2\#acq(y) the pre vector clock would be $[2,0]$ and the post vector clock $[3,0]$. To enforce the critical section order condition the pre vector clock of an acquire event following a release event on the same lock has to be synchronized. The post vector clock of the acquire event will be the incremented synchronized vector clock. In trace \ref{trace1} the pre vector clock of 3\#rel(y) is $[3,0]$ and $[0,1]$ for 4\#acq(y). So the synchronized vector clock is $V_2=[3,1]$ and after applying $\text{inc}(V_2,2)$, the vector clock for 4\#acq(y) would be $[3,2]$. For further details on vector clocks, see \cite[p. 8]{sulzmann2}\cite.
		\subsection{Epoch}
%		\begin{itemize}
%			\item was genau ist ein data race
%			\item wie k\"onnen data races dynamisch erkannt werden?
%			\item happens-before Methode \cite[p. 4]{FAVA2020102473}
%		\end{itemize}
	
	\section{FastTrack + TSan}\label{fasttrack-sec}
	\lstinputlisting[caption={Program demonstrating the incompleteness of TSan}, label={lst:incomplete}, language=C++]{incomplete.cpp}
	As seen in \cite{marthur} Lamport's happens-before relation is also unsound. Because FastTrack and TSan both use the HB relation they might produce false positives as a result. The following program \ref{lst:unsound} shows an example in which TSan produces a false negative:
	\lstinputlisting[caption={Program demonstrating the unsoundness of TSan}, label={lst:unsound}, language=C++]{unsoundness.cpp}
	The program \ref{lst:unsound} may produce the following trace \ref{trace3}:
	\begin{table}[H]
		\begin{center}
			\begin{tabular}{ c c c}
				& 1\# & 2\# \\
				\hline
				1. & r(x) & \\
				2. & w(y) & \\
				3. & & r(y) \\
				4. & & w(x) \\
			\end{tabular}
			\caption{Possible trace of listing \ref{lst:unsound}}
			\label{trace3}
		\end{center}
	\end{table}
	Describe shadow cells and shadow words, then example...
	\lstinputlisting[caption={Program showing a missed data race due to the limit on shadow words}]{shadow_word_limitation.cpp}
%	\begin{itemize}
%		\item Effiziente Umsetzung der happens-before methode
%		\item FastTrack uses an optimized semi-adaptive version of epochs
%	\end{itemize}
	
	
	\section{Conclusion}
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%%| BIBLIOGRAPHY |%%                 
	\newpage                                          
	\printbibliography[heading= bibintoc, title={List of Literature}]
	\newpage
	{\hypersetup{linkcolor=black}
		\listoffigures
		\addcontentsline{toc}{section}{List of Figures}
		\newpage
		\listoftables
		\addcontentsline{toc}{section}{List of Tables}
		\newpage
		\lstlistoflistings
		\addcontentsline{toc}{section}{List of Listings}
	}

\end{document}